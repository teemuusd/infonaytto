<!doctype html>
<html lang="fi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Tulli — infonäyttö</title>
<style>
  :root{--bg:#0b0c0d;--muted:#9aa0a6;--accent:#00bfb3;--feedback-bg:#1a1a2e}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Inter,Segoe UI,Arial,sans-serif}
  .wrap{display:grid;grid-template-columns:repeat(3, 1fr);gap:18px;padding:28px;box-sizing:border-box;height:100%}
  header{grid-column:1/-1;display:flex;align-items:center;justify-content:space-between}
  h1{margin:0;font-size:28px;letter-spacing:0.4px}
  .clock{font-size:20px;color:var(--muted)}
  .card{
    background:rgba(255,255,255,0.03);
    border-radius:12px;
    padding:18px;
    display:flex;
    flex-direction:column;
    overflow: hidden;
  }
  .station-title{font-size:18px;color:var(--muted);margin-bottom:8px}
  .line-block{margin-bottom:12px}
  .line-title{font-weight:700;font-size:20px;margin-bottom:6px}
  .direction{font-size:16px;color:var(--muted);margin-bottom:6px}
  .departures{display:flex;flex-direction:column;gap:6px}
  .dep{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.02)}
  .dep .route{font-weight:700}
  .dep .time{font-size:18px}
  footer{grid-column:1/-1;color:var(--muted);font-size:13px;margin-top:6px}
  .now{color:#00bfb3;font-weight:700;}

  .feedback-card { background: var(--feedback-bg); grid-column: 3 / 4; }
  .feedback-title { color: var(--accent); font-size: 20px; margin-bottom: 15px; }
  .feedback-list { display: flex; flex-direction: column; gap: 15px; overflow: hidden; }
  .feedback-item { padding-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); }
  .feedback-item:last-child { border-bottom: none; padding-bottom: 0; }
  .feedback-content { font-size: 16px; line-height: 1.4; margin-bottom: 5px; }
  .feedback-author { font-style: italic; color: var(--muted); text-align: right; font-size: 14px; }

  .weather-widget { display: flex; align-items: center; gap: 10px; justify-content: flex-end; }
  .weather-temp { font-size: 24px; font-weight: bold; color: white; }
  .weather-desc { font-size: 16px; color: var(--muted); }

  @media(max-width:1200px){
    .wrap{grid-template-columns:1fr 1fr;}
    .feedback-card { grid-column: 1 / -1; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Tullin pysäkiltä lähtevät ratikat</h1>
      <div id="weather-content" class="weather-widget">
        <span class="weather-loading">Ladataan säätä...</span>
      </div>
      <div class="clock" id="clock">--:--</div>
    </header>

    <div class="card" id="card-A">
      <div class="station-title">Tulli A </div>
      <div id="content-A">Ladataan...</div>
    </div>

    <div class="card" id="card-B">
      <div class="station-title">Tulli B </div>
      <div id="content-B">Ladataan...</div>
    </div>
    
    <div class="card feedback-card">
      <div class="feedback-title">Positiiviset palautteet</div>
      <div id="feedback-display" class="feedback-list">
        Ladataan palautteita...
      </div>
    </div>

    <footer>Data: Nysse / ITS Factory Journeys API • Päivittyy 10 s välein</footer>
  </div>

<script>
// --- ASETUKSET ---
const API_BASE = 'https://data.itsfactory.fi'; // PROTOKOLLI MUKANA
const STOP_A = '0811';
const STOP_B = '0812';
const LINES_WANTED = ['1','3'];
const FEEDBACK_FILE = 'palautteet.json';
// -------------------

// --- KELLO ---
function updateClock(){
  const el = document.getElementById('clock');
  const now = new Date();
  const hh = String(now.getHours()).padStart(2,'0');
  const mm = String(now.getMinutes()).padStart(2,'0');
  const ss = String(now.getSeconds()).padStart(2,'0');
  el.textContent = `${hh}:${mm}:${ss}`;
}
setInterval(updateClock,1000);
updateClock();

// --- PYSÄKKIEN LOGIIKKA ---
async function fetchJourneysFor(stopId){
  const url = `${API_BASE}/journeys?stopPointId=${encodeURIComponent(stopId)}&pageSize=200`;
  console.log('Fetching', url);
  const res = await fetch(url);
  if(!res.ok) throw new Error('HTTP ' + res.status + ' ' + res.statusText);
  return (await res.json()).journeys || [];
}

function normalizeJourneys(rawList){
  const out = [];
  const seen = new Set();
  (rawList || []).forEach(j => {
    const line = j.line?.name || j.line?.shortName || j.lineName || '';
    const headsign = j.headSign || j.destination || '';
    // turvallinen haku mahdollisista kentistä
    let departureISO = null;
    if (j.onwardCalls && j.onwardCalls.length && j.onwardCalls[0].expectedDepartureTime) {
      departureISO = j.onwardCalls[0].expectedDepartureTime;
    } else if (j.expectedDepartureTime) {
      departureISO = j.expectedDepartureTime;
    } else if (j.departureTime) {
      // jos on vain "HH:MM:SS" ilman päivämäärää => liitetään tämän päivän päivämäärä (paikallinen)
      const todayLocal = new Date();
      const d = todayLocal.toISOString().slice(0,10);
      departureISO = d + 'T' + j.departureTime;
    }
    const key = `${line}|${headsign}|${departureISO}`;
    if(!seen.has(key)){
      out.push({line: String(line).trim(), headsign: headsign || '', departureISO});
      seen.add(key);
    }
  });
  return out;
}

function minutesUntil(iso){
  if(!iso) return null;
  const t = Date.parse(iso);
  if(isNaN(t)) return null;
  return Math.round((t - Date.now()) / 60000);
}

function renderFor(containerId, journeys){
  const el = document.getElementById(containerId);
  if(!journeys || journeys.length === 0){
    el.innerHTML = '<div class="direction">Ei lähteviä vuoroja tiedossa.</div>';
    return;
  }
  const filtered = journeys
    .filter(j => {
      // robustimpi matching: hyväksytään esim '1A' kun haetaan '1'
      const normalized = String(j.line || '').replace(/\s/g,'').toLowerCase();
      return LINES_WANTED.some(w => normalized.startsWith(String(w).toLowerCase()));
    })
    .filter(j => {
      const mins = minutesUntil(j.departureISO);
      return mins !== null && mins >= 0;
    });
  if(filtered.length === 0){
    el.innerHTML = '<div class="direction">Ei linjoja 1 tai 3 juuri nyt.</div>';
    return;
  }
  const groups = {};
  filtered.forEach(j => {
    const key = `${j.line} — ${j.headsign || '—'}`;
    groups[key] = groups[key] || [];
    groups[key].push(j);
  });
  let html = '';
  Object.keys(groups).sort().forEach(k => {
    const arr = groups[k].sort((a,b) => {
      const ma = minutesUntil(a.departureISO) ?? 9999;
      const mb = minutesUntil(b.departureISO) ?? 9999;
      return ma - mb;
    }).slice(0,5);
    const [line, headsign] = k.split(' — ');
    html += `<div class="line-block"><div class="line-title">Linja ${line}</div><div class="direction">${headsign}</div><div class="departures">`;
    let nowShown = false;
    arr.forEach(item => {
      const mins = minutesUntil(item.departureISO);
      const arrivalTime = item.departureISO ? new Date(item.departureISO) : null;
      const arrivalStr = arrivalTime ? arrivalTime.getHours().toString().padStart(2,'0') + ':' + arrivalTime.getMinutes().toString().padStart(2,'0') : '—';
      let timeLabel;
      if(mins === null){
        timeLabel = arrivalStr;
      } else if(mins <= 0 && !nowShown){
        timeLabel = `<span class="now">nyt</span> (${arrivalStr})`;
        nowShown = true;
      } else {
        timeLabel = mins + ' min' + ` (${arrivalStr})`;
      }
      html += `<div class="dep"><div class="route">${line} → ${item.headsign || '—'}</div><div class="time">${timeLabel}</div></div>`;
    });
    html += `</div></div>`;
  });
  el.innerHTML = html;
}

async function updateAll(){
  try{
    const normA = normalizeJourneys(await fetchJourneysFor(STOP_A));
    renderFor('content-A', normA);
  }catch(err){ console.error("Error updating A:", err); document.getElementById('content-A').innerHTML = '<div class="direction">Virhe ladattaessa pysäkki A.</div>'; }
  try{
    const normB = normalizeJourneys(await fetchJourneysFor(STOP_B));
    renderFor('content-B', normB);
  }catch(err){ console.error("Error updating B:", err); document.getElementById('content-B').innerHTML = '<div class="direction">Virhe ladattaessa pysäkki B.</div>'; }
}
updateAll();
setInterval(updateAll, 10000);

// --- Palautteet (Näytä vain uusimmat, mahtuvat kerralla) ---
async function fetchAndDisplayFeedbacks() {
  try {
    const res = await fetch(FEEDBACK_FILE);
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const allFeedbacks = await res.json();
    const feedbackDisplayEl = document.getElementById('feedback-display');

    if (allFeedbacks.length > 0) {
      // tehdään kopio ja käännetään, jotta emme mutatoi alkuperäistä
      const newestFirst = allFeedbacks.slice().reverse();
      let html = '';

      newestFirst.forEach(feedback => {
        html += `
          <div class="feedback-item">
            <div class="feedback-content">"${feedback.Palaute}"</div>
            <div class="feedback-author">— ${feedback.nimimerkki || 'Anonyymi'}</div>
          </div>
        `;
      });
      feedbackDisplayEl.innerHTML = html;
    } else {
      feedbackDisplayEl.textContent = 'Ei näytettäviä palautteita.';
    }
  } catch (err) {
    console.error("Error fetching feedbacks:", err);
    document.getElementById('feedback-display').textContent = 'Virhe ladattaessa palautteita.';
  }
}
fetchAndDisplayFeedbacks();

// --- Sään haku (Open-Meteo) ---
async function loadWeather(){
  try{
    // käytetään geolokaatiota jos saatavilla, muuten fallback
    const getCoords = () => new Promise(resolve => {
      if(navigator.geolocation){
        navigator.geolocation.getCurrentPosition(pos => {
          resolve({lat: pos.coords.latitude, lon: pos.coords.longitude});
        }, _err => {
          resolve({lat:60.1699, lon:24.9384}); // fallback: Helsinki
        }, {timeout:5000});
      } else {
        resolve({lat:60.1699, lon:24.9384});
      }
    });
    const coords = await getCoords();
    const url = `https://api.open-meteo.com/v1/forecast?latitude=${encodeURIComponent(coords.lat)}&longitude=${encodeURIComponent(coords.lon)}&current_weather=true&timezone=auto`;
    console.log('Fetching weather', url);
    const r = await fetch(url);
    if(!r.ok) throw new Error('HTTP ' + r.status);
    const d = await r.json();
    if(!d.current_weather) throw new Error('No current_weather in response');
    const t = Math.round(d.current_weather.temperature);
    const code = d.current_weather.weathercode;

    const desc = (()=>{
      switch(code){
        case 0: return "Selkeää";
        case 1: return "Melkein selkeää";
        case 2: return "Puolipilvistä";
        case 3: return "Pilvistä";
        case 45: return "Sumua";
        case 48: return "Jäätävää sumua";
        case 51: return "Tihkua";
        case 61: return "Vesisadetta";
        case 71: return "Lumikuuroja";
        default: return "Säätietoja ei saatavilla";
      }
    })();

    document.getElementById("weather-content").innerHTML = `
      <div class="weather-temp">${t}°C</div>
      <div class="weather-desc">${desc}</div>
    `;
  }catch(e){
    console.error('Weather error', e);
    document.getElementById("weather-content").textContent = "Virhe ladattaessa säätä.";
  }
}
loadWeather();
setInterval(loadWeather, 900000);

</script>
</body>
</html>
