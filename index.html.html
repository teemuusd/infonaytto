<!doctype html>
<html lang="fi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Tulli — infonäyttö</title>
<style>
  :root{--bg:#0b0c0d;--muted:#9aa0a6;--accent:#00bfb3;--feedback-bg:#1a1a2e}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Inter,Segoe UI,Arial,sans-serif}
  .wrap{display:grid;grid-template-columns:repeat(3, 1fr);gap:18px;padding:28px;box-sizing:border-box;height:100%}
  header{grid-column:1/-1;display:flex;align-items:center;justify-content:space-between}
  h1{margin:0;font-size:28px;letter-spacing:0.4px}
  .clock{font-size:20px;color:var(--muted)}
  .card{
    background:rgba(255,255,255,0.03);
    border-radius:12px;
    padding:18px;
    display:flex;
    flex-direction:column;
    /* Poistettu min-height, kortin koko määräytyy sisällön ja flexboxin mukaan */
    overflow: hidden; /* Estää sisällön valumisen ulos kortista */
  }
  .station-title{font-size:18px;color:var(--muted);margin-bottom:8px}
  .line-block{margin-bottom:12px}
  .line-title{font-weight:700;font-size:20px;margin-bottom:6px}
  .direction{font-size:16px;color:var(--muted);margin-bottom:6px}
  .departures{display:flex;flex-direction:column;gap:6px}
  .dep{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.02)}
  .dep .route{font-weight:700}
  .dep .time{font-size:18px}
  footer{grid-column:1/-1;color:var(--muted);font-size:13px;margin-top:6px}
  .now{color:#00bfb3;font-weight:700;}

  /* Palautteet ja Sää tyylit */
  .feedback-card {
    background: var(--feedback-bg);
    grid-column: 3 / 4;
  }
  .feedback-title { color: var(--accent); font-size: 20px; margin-bottom: 15px; }
  .feedback-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
    /* Tärkeä asetus, jotta lista ei veny loputtomiin flex-säiliössä: */
    overflow: hidden; 
  }
  .feedback-item { padding-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); }
  .feedback-item:last-child { border-bottom: none; padding-bottom: 0; }
  .feedback-content { font-size: 16px; line-height: 1.4; margin-bottom: 5px; }
  .feedback-author { font-style: italic; color: var(--muted); text-align: right; font-size: 14px; }

  .weather-widget { display: flex; align-items: center; gap: 10px; justify-content: flex-end; }
  .weather-temp { font-size: 24px; font-weight: bold; color: white; }
  .weather-desc { font-size: 16px; color: var(--muted); }

  @media(max-width:1200px){
    .wrap{grid-template-columns:1fr 1fr;}
    .feedback-card { grid-column: 1 / -1; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Tullin pysäkiltä lähtevät ratikat</h1>
      <div id="weather-content" class="weather-widget">
        <span class="weather-loading">Ladataan säätä...</span>
      </div>
      <div class="clock" id="clock">--:--</div>
    </header>

    <div class="card" id="card-A">
      <div class="station-title">Tulli A </div>
      <div id="content-A">Ladataan...</div>
    </div>

    <div class="card" id="card-B">
      <div class="station-title">Tulli B </div>
      <div id="content-B">Ladataan...</div>
    </div>
    
    <div class="card feedback-card">
      <div class="feedback-title">Positiiviset palautteet</div>
      <div id="feedback-display" class="feedback-list">
        Ladataan palautteita...
      </div>
    </div>

    <footer>Data: Nysse / ITS Factory Journeys API • Päivittyy 10 s välein</footer>
  </div>

<script>
// --- ASETUKSET ---
const API_BASE = 'data.itsfactory.fi';
const STOP_A = '0811';
const STOP_B = '0812';
const LINES_WANTED = ['1','3'];
const FEEDBACK_FILE = 'palautteet.json';
// Open-Meteo ei vaadi API-avainta, käytetään toimivaa koodia
// -------------------


// --- KELLO ---
function updateClock(){
  const el = document.getElementById('clock');
  const now = new Date();
  const hh = String(now.getHours()).padStart(2,'0');
  const mm = String(now.getMinutes()).padStart(2,'0');
  const ss = String(now.getSeconds()).padStart(2,'0');
  el.textContent = `${hh}:${mm}:${ss}`;
}
setInterval(updateClock,1000);
updateClock();

// --- PYSÄKKIEN LOGIIKKA (Toimii localhostissa) ---

async function fetchJourneysFor(stopId){
  const url = `${API_BASE}/journeys?stopPointId=${encodeURIComponent(stopId)}&pageSize=200`;
  const res = await fetch(url);
  if(!res.ok) throw new Error('HTTP ' + res.status);
  return (await res.json()).journeys || [];
}

function normalizeJourneys(rawList){
  const out = [];
  const seen = new Set();
  (rawList || []).forEach(j => {
    const line = j.line?.name || j.line?.shortName || j.lineName || '';
    const headsign = j.headSign || j.destination || '';
    let departureISO = j.onwardCalls?.?.expectedDepartureTime || j.expectedDepartureTime || null;
    if(!departureISO && j.departureTime){
      const today = new Date();
      const d = today.toISOString().slice(0,10);
      departureISO = d + 'T' + j.departureTime;
    }
    const key = `${line}|${headsign}|${departureISO}`;
    if(!seen.has(key)){
      out.push({line: String(line).trim(), headsign: headsign || '', departureISO});
      seen.add(key);
    }
  });
  return out;
}

function minutesUntil(iso){
  if(!iso) return null;
  const t = Date.parse(iso);
  if(isNaN(t)) return null;
  return Math.round((t - Date.now()) / 60000);
}

function renderFor(containerId, journeys){
  const el = document.getElementById(containerId);
  if(!journeys || journeys.length === 0){
    el.innerHTML = '<div class="direction">Ei lähteviä vuoroja tiedossa.</div>';
    return;
  }
  const filtered = journeys
    .filter(j => LINES_WANTED.includes(String(j.line).replace(/\s/g,'')))
    .filter(j => {
      const mins = minutesUntil(j.departureISO);
      return mins !== null && mins >= 0;
    });
  if(filtered.length === 0){
    el.innerHTML = '<div class="direction">Ei linjoja 1 tai 3 juuri nyt.</div>';
    return;
  }
  const groups = {};
  filtered.forEach(j => {
    const key = `${j.line} — ${j.headsign || '—'}`;
    groups[key] = groups[key] || [];
    groups[key].push(j);
  });
  let html = '';
  Object.keys(groups).sort().forEach(k => {
    const arr = groups[k].sort((a,b) => {
      const ma = minutesUntil(a.departureISO) ?? 9999;
      const mb = minutesUntil(b.departureISO) ?? 9999;
      return ma - mb;
    }).slice(0,5);
    const [line, headsign] = k.split(' — ');
    html += `<div class="line-block"><div class="line-title">Linja ${line}</div><div class="direction">${headsign}</div><div class="departures">`;
    let nowShown = false;
    arr.forEach(item => {
      const mins = minutesUntil(item.departureISO);
      const arrivalTime = item.departureISO ? new Date(item.departureISO) : null;
      const arrivalStr = arrivalTime ? arrivalTime.getHours().toString().padStart(2,'0') + ':' + arrivalTime.getMinutes().toString().padStart(2,'0') : '—';
      let timeLabel;
      if(mins === null){
        timeLabel = arrivalStr;
      } else if(mins <= 0 && !nowShown){
        timeLabel = `<span class="now">nyt</span> (${arrivalStr})`;
        nowShown = true;
      } else {
        timeLabel = mins + ' min' + ` (${arrivalStr})`;
      }
      html += `<div class="dep"><div class="route">${line} → ${item.headsign || '—'}</div><div class="time">${timeLabel}</div></div>`;
    });
    html += `</div></div>`;
  });
  el.innerHTML = html;
}

async function updateAll(){
  try{
    const normA = normalizeJourneys(await fetchJourneysFor(STOP_A));
    renderFor('content-A', normA);
  }catch(err){ console.error("Error updating A:", err); document.getElementById('content-A').innerHTML = '<div class="direction">Virhe ladattaessa pysäkki A.</div>'; }
  try{
    const normB = normalizeJourneys(await fetchJourneysFor(STOP_B));
    renderFor('content-B', normB);
  }catch(err){ console.error("Error updating B:", err); document.getElementById('content-B').innerHTML = '<div class="direction">Virhe ladattaessa pysäkki B.</div>'; }
}
updateAll();
setInterval(updateAll, 10000);


// --- Palautteet (Näytä vain uusimmat, mahtuvat kerralla) ---

async function fetchAndDisplayFeedbacks() {
  try {
    const res = await fetch(FEEDBACK_FILE);
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const allFeedbacks = await res.json();
    const feedbackDisplayEl = document.getElementById('feedback-display');

    if (allFeedbacks.length > 0) {
      // Käännetään järjestys, jotta uusin (tiedoston lopussa oleva) näkyy ensin
      const newestFirst = allFeedbacks.reverse(); 
      let html = '';

      newestFirst.forEach(feedback => {
        html += `
          <div class="feedback-item">
            <div class="feedback-content">"${feedback.Palaute}"</div>
            <div class="feedback-author">— ${feedback.nimimerkki || 'Anonyymi'}</div>
          </div>
        `;
      });
      feedbackDisplayEl.innerHTML = html;
      
      // HUOM: Koska käytämme CSS:n 'overflow: hidden' ominaisuutta emme tarvitse erillistä JS-logiikkaa rajaamiseen. 
      // Vanhimmat palautteet jäävät automaattisesti näkymättä kortin alareunaan.

    } else {
      feedbackDisplayEl.textContent = 'Ei näytettäviä palautteita.';
    }
  } catch (err) {
    console.error("Error fetching feedbacks:", err);
    document.getElementById('feedback-display').textContent = 'Virhe ladattaessa palautteita.';
  }
}
fetchAndDisplayFeedbacks();


// --- Sään haku (Toimiva Open-Meteo koodi) ---

async function loadWeather(){
  try{
    const url = "api.open-meteo.com";
    const r = await fetch(url);
    const d = await r.json();
    const t = Math.round(d.current.temperature_2m);
    const code = d.current.weather_code;

    const desc = ({
      0:"Selkeää", 1:"Melkein selkeää", 2:"Puolipilvistä", 3:"Pilvistä", 
      45:"Sumua", 48:"Jäätävää sumua", 51:"Tihkua", 61:"Vesisadetta", 
      71:"Lumikuuroja"
    })[code] || "Säätietoja ei saatavilla";

    document.getElementById("weather-content").innerHTML = `
      <div class="weather-temp">${t}°C</div>
      <div class="weather-desc">${desc}</div>
    `;
  }catch(e){
    document.getElementById("weather-content").textContent = "Virhe ladattaessa säätä.";
  }
}
loadWeather();
setInterval(loadWeather, 900000);

</script>
</body>
</html>
